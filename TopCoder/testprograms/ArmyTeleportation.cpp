#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <assert.h>

#define in freopen("input.txt", "r", stdin);
#define out freopen("output.txt", "w", stdout);
#define clr(arr, key) memset(arr, key, sizeof arr)
#define pb push_back
#define mp(a, b) make_pair(a, b)
#define infinity (1 << 28)
#define LL long long
#define PI acos(-1)
#define gcd(a, b) __gcd(a, b)
#define CF ios_base::sync_with_stdio(0);cin.tie(0);
#define lcm(a, b) ((a)*((b)/gcd(a,b)))
#define all(v) v.begin(), v.end()
#define no_of_ones __builtin_popcount // count 1's in a numbers binary representation
#define SZ(v) (int)(v.size())
#define eps 10e-7

//int col[8] = {0, 1, 1, 1, 0, -1, -1, -1};
//int row[8] = {1, 1, 0, -1, -1, -1, 0, 1};
//int col[4] = {1, 0, -1, 0};
//int row[4] = {0, 1, 0, -1};
//int months[13] = {0, ,31,28,31,30,31,30,31,31,30,31,30,31};

using namespace std;

//struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};    // for coordinates;
//
//template <class T> T sqr(T a){return a * a;}    // square
//template <class T> T power(T n, T p) { T res = 1; for(int i = 0; i < p; i++) res *= n; return res;}     //  n  to the power p
//template <class T> double getdist(T a, T b){return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));}    // distance between a and b
//template <class T> T extract(string s, T ret) {stringstream ss(s); ss >> ret; return ret;}    // extract words or numbers from a line
//template <class T> string tostring(T n) {stringstream ss; ss << n; return ss.str();}    // convert a number to string
//template <class T> inline T Mod(T n,T m) {return (n%m+m)%m;}    // negative mod
//template <class T> void show(T a){cout << a << endl;}
//template <class T> void show(T a, T b){cout << a << ' ' << b << endl;}
//LL bigmod(LL B,LL P,LL M){LL R=1; while(P>0)  {if(P%2==1){R=(R*B)%M;}P/=2;B=(B*B)%M;} return R;}

#define MAX 200010
/***********************************THE GRASS IS ALWAYS GREENER ON THE OTHER SIDE***********************************/

class ArmyTeleportation {
public:
	string ifPossible(vector <int> x1, vector <int> y1, vector <int> x2, vector <int> y2, vector <int> xt, vector <int> yt) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, vector <int> p2, vector <int> p3, vector <int> p4, vector <int> p5, bool hasAnswer, string p6) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p3[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p4.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p4[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p5.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p5[i];
	}
	cout << "}";
	cout << "]" << endl;
	ArmyTeleportation *obj;
	string answer;
	obj = new ArmyTeleportation();
	clock_t startTime = clock();
	answer = obj->ifPossible(p0, p1, p2, p3, p4, p5);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p6 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p6;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <int> p0;
	vector <int> p1;
	vector <int> p2;
	vector <int> p3;
	vector <int> p4;
	vector <int> p5;
	string p6;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {0,1};
	p1 = {0,1};
	p2 = {2,1};
	p3 = {4,3};
	p4 = {2,3,2};
	p5 = {0,1,3};
	p6 = "possible";
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, p5, true, p6) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {0,1,2};
	p1 = {2,4,6};
	p2 = {3,5,6};
	p3 = {1,1,0};
	p4 = {3,1,-2};
	p5 = {4,2,10};
	p6 = "impossible";
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, p5, true, p6) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {0,1};
	p1 = {1,2};
	p2 = {1,2};
	p3 = {2,3};
	p4 = {0,0,0};
	p5 = {5,3,8};
	p6 = "impossible";
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, p5, true, p6) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {6,-5,1};
	p1 = {3,-10,-7};
	p2 = {0,11,5};
	p3 = {-5,8,5};
	p4 = {0,-5,4};
	p5 = {-8,-9,-4};
	p6 = "possible";
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, p5, true, p6) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {3,2,1};
	p1 = {1,2,3};
	p2 = {4,5,6};
	p3 = {6,5,4};
	p4 = {-2,5,6};
	p5 = {1,-3,2};
	p6 = "impossible";
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, p5, true, p6) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = {903,-970,404,563};
	p1 = {-348,-452,37,692};
	p2 = {3359,1486,2860,3019};
	p3 = {-416,-520,-31,624};
	p4 = {346,-838,916};
	p5 = {-541,-717,-348};
	p6 = "possible";
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, p3, p4, p5, true, p6) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 6 -----
	disabled = false;
	p0 = {4600,8914,9330,-193,5422};
	p1 = {25,7650,-7366,-8494,-6574};
	p2 = {-117326,-121640,-122056,-112533,-118148};
	p3 = {322619,314994,330010,331138,329218};
	p4 = {9523,-7546,-9858};
	p5 = {-3750,-5347,-3828};
	p6 = "impossible";
	all_right = (disabled || KawigiEdit_RunTest(6, p0, p1, p2, p3, p4, p5, true, p6) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 7 -----
	disabled = false;
	p0 = {4514,-67225,-78413,-96468,-58938};
	p1 = {-22815,-86062,-54529,-87391,42044};
	p2 = {259998,331737,342925,360980,323450};
	p3 = {912263,975510,943977,976839,847404};
	p4 = {23726,-98808,-26788};
	p5 = {80876,-68160,-13684};
	p6 = "possible";
	all_right = (disabled || KawigiEdit_RunTest(7, p0, p1, p2, p3, p4, p5, true, p6) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// King Janusz is in great trouble.
// His enemies have attacked his kingdom from a direction the king did not expect and now he must relocate his troops quickly.
// The desperate king asked the great sorcerer Mirek for help.
// 
// Mirek has three magic towers that are able to teleport troops.
// Each time a tower is activated, all soldiers get teleported to new locations.
// The new location is computed by reflecting the old position through the position of the activated tower.
// (In other words, the activated tower will be in the middle of each segment that connects the old and the new position of a soldier.)
// 
// The king can activate the towers in any order he likes.
// Each tower can be activated arbitrarily many times.
// 
// You are given the current locations of the troops in vector <int>s x1 and y1.
// For each valid i, there is a soldier on the point (x1[i], y1[i]).
// You are also given the desired locations of the troops in vector <int>s x2 and y2.
// For each valid i, the King wants to have a soldier on the point (x2[i], y2[i]).
// Finally, you are given the coordinates of the three towers in vector <int>s xt and yt.
// 
// The soldiers are not allowed to move in any way other than by teleportation.
// The order of soldiers does not have to be preserved.
// (For example, the soldier that started at (x1[0], y1[0]) may end at (x2[2], y2[2]).)
// 
// Return "possible" (quotes for clarity) if it is possible to reach the state in which there are soldiers at all desired locations.
// Otherwise, return "impossible".
// 
// 
// DEFINITION
// Class:ArmyTeleportation
// Method:ifPossible
// Parameters:vector <int>, vector <int>, vector <int>, vector <int>, vector <int>, vector <int>
// Returns:string
// Method signature:string ifPossible(vector <int> x1, vector <int> y1, vector <int> x2, vector <int> y2, vector <int> xt, vector <int> yt)
// 
// 
// CONSTRAINTS
// -x1, y1, x2 and y2 will have the same number of element which will be between 1 and 50, inclusive.
// -xt and yt will have exactly 3 elements each.
// -The points described by x1 and y1 are pairwise distinct.
// -The points described by x2 and y2 are pairwise distinct.
// -The points described by xt and yt are pairwise distinct.
// -Each element of x1, y1, x2, y2, xt and yt will be between -1,000,000 and 1,000,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {0, 1}
// {0, 1}
// {2, 1}
// {4, 3}
// {2, 3, 2}
// {0, 1, 3}
// 
// Returns: "possible"
// 
// We have soldiers at (0,0) and (1,1).
// We want to have soldiers at (2,4) and (1,3).
// There are three towers: at (2,0), (3,1), and (2,3).
// 
// Mirek can teleport the king's troops as follows:
// 
// He will activate the tower at (2,0). One soldier will teleport from (0,0) to (4,0), the other from (1,1) to (3,-1).
// He will activate the tower at (3,1), teleporting the soldiers to (2,2) and (3,3).
// He will activate the tower at (2,3), teleporting the soldiers to (2,4) and (1,3), as desired.
// 
// 
// 1)
// {0, 1, 2}
// {2, 4, 6}
// {3, 5, 6}
// {1, 1, 0}
// {3, 1, -2}
// {4, 2, 10}
// 
// Returns: "impossible"
// 
// The soldiers are standing in a line. It is impossible to change that during the teleportation.
// 
// 2)
// {0, 1}
// {1, 2}
// {1, 2}
// {2, 3}
// {0, 0, 0}
// {5, 3, 8}
// 
// Returns: "impossible"
// 
// Regardless of the order of teleportation, the soldier that starts at (0,1) will always have his x coordinate equal to zero.
// Therefore he will never reach any of the desired destinations.
// 
// 3)
// {6, -5, 1}
// {3, -10, -7}
// {0, 11, 5}
// {-5, 8, 5}
// {0, -5, 4}
// {-8, -9, -4}
// 
// Returns: "possible"
// 
// 
// 
// 4)
// {3, 2, 1}
// {1, 2, 3}
// {4, 5, 6}
// {6, 5, 4}
// {-2, 5, 6}
// {1, -3, 2}
// 
// Returns: "impossible"
// 
// 
// 
// 5)
// {903, -970, 404, 563}
// {-348, -452, 37, 692}
// {3359, 1486, 2860, 3019}
// {-416, -520, -31, 624}
// {346, -838, 916}
// {-541, -717, -348}
// 
// Returns: "possible"
// 
// 
// 
// 6)
// {4600, 8914, 9330, -193, 5422}
// {25, 7650, -7366, -8494, -6574}
// {-117326, -121640, -122056, -112533, -118148}
// {322619, 314994, 330010, 331138, 329218}
// {9523, -7546, -9858}
// {-3750, -5347, -3828}
// 
// Returns: "impossible"
// 
// 
// 
// 7)
// {4514, -67225, -78413, -96468, -58938}
// {-22815, -86062, -54529, -87391, 42044}
// {259998, 331737, 342925, 360980, 323450}
// {912263, 975510, 943977, 976839, 847404}
// {23726, -98808, -26788}
// {80876, -68160, -13684}
// 
// Returns: "possible"
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
