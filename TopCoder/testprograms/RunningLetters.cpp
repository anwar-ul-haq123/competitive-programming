#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

#define out freopen("output.txt", "w", stdout);
#define in freopen("input.txt", "r", stdin);
#define clr(arr, key) memset(arr, key, sizeof arr)
#define pb push_back
#define infinity (1 << 28)
#define LL long long
#define PI acos(-1)
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) ((a)*((b)/gcd(a,b)))
#define all(v) v.begin(), v.end()
#define no_of_ones __builtin_popcount // count 1's in a numbers binary representation
#define SZ(v) (int)(v.size())
#define eps 10e-7

//int col[8] = {0, 1, 1, 1, 0, -1, -1, -1};
//int row[8] = {1, 1, 0, -1, -1, -1, 0, 1};
//int col[4] = {1, 0, -1, 0};
//int row[4] = {0, 1, 0, -1};
//int months[13] = {0, ,31,28,31,30,31,30,31,31,30,31,30,31};

using namespace std;

struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};    // for coordinates;

template <class T> T sqr(T a){return a * a;}    // square
template <class T> T power(T n, T p) { T res = 1; for(int i = 0; i < p; i++) res *= n; return res;}     //  n  to the power p
template <class T> double getdist(T a, T b){return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));}    // distance between a and b
template <class T> T extract(string s, T ret) {stringstream ss(s); ss >> ret; return ret;}    // extract words or numbers from a line
template <class T> string tostring(T n) {stringstream ss; ss << n; return ss.str();}    // convert a number to string
template <class T> inline T Mod(T n,T m) {return (n%m+m)%m;}    // negative mod
template <class T> void print_all(T v) {for(int i = 0; i < v.size(); i++) cout << v[i] << ' ';};
template <class T> void print_all(T &v, int len) {for(int i = 0; i < len; i++) cout << v[i] << ' ';}     // prints all elements in a vector or array
template <class T> void print_pair(T v, int len) {for(int i = 0; i < len; i++) cout << v[i].first << ' ' << v[i].second << endl;} // prints pair vector
//LL bigmod(LL B,LL P,LL M){LL R=1; while(P>0)  {if(P%2==1){R=(R*B)%M;}P/=2;B=(B*B)%M;} return R;}

#define MAX 100010
/*************************************************HABIJABI ENDS HERE******************************************************/

class RunningLetters {
public:
    int match[MAX];

    int compute_match_array(string pat)
    {
        int m = SZ(pat);
        int len = 0;
        int i;
        match[0] = 0, i = 1;
        // calculate match[i] for i = 1 to m - 1
        while(i < m)
        {
            if(pat[i] == pat[len])
            {
                len++;
                match[i] = len;
                i++;
            }
            else
            {
                if(len != 0)
                    len = match[len - 1];
                else
                {
                    match[i] = 0;
                    i++;
                }
            }
        }
        return match[m - 1];
    }
	int newsLength(vector <string> running) {
	    string s, tem;
	    int times;
	    for(int i = 0; i < SZ(running); i++)
        {
            stringstream ss(running[i]);
            while(ss >> times && ss >> tem)
            {
                while(times--)
                    s += tem;
            }
        }
		return SZ(s) - compute_match_array(s);
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	RunningLetters *obj;
	int answer;
	obj = new RunningLetters();
	clock_t startTime = clock();
	answer = obj->newsLength(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;

	vector <string> p0;
	int p1;

	// ----- test 0 -----
	disabled = false;
	p0 = {"3 abc 1 ab"};
	p1 = 3;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 1 -----
	disabled = false;
	p0 = {"1 babaaba"};
	p1 = 5;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 2 -----
	disabled = false;
	p0 = {"1 ba 1 c 1 bacba 3 cba"};
	p1 = 3;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 3 -----
	disabled = false;
	p0 = {"42 runningletters 42 runningletters 1 running"};
	p1 = 14;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 4 -----
	disabled = false;
	p0 = {"1 b ","1 a ","1 b ","1 a"," 1 b"};
	p1 = 2;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// There is an electronic sign above the entrance to FIELD-Tech headquarters.  The sign displays a scrolling message that is repeated over and over again.  The letters show up on one side of the sign, scroll to the other side, and then disappear.  Polly, who works in the office, is curious about the length of the message.  She has observed the sign for some period of time and written down the letters she has seen, in order.  Now, you must help her determine the minimal possible length of the message.  For example, if she saw the letters "abcabcabcab", two possible messages would be "bca" and "abcabc".  The shortest possible length would be 3.
//
// You will be given a vector <string> running.  Concatenate the elements of running to get a space separated list of sections, each formatted "N S" (quotes for clarity), representing the concatenation of N instances of S.  Expand out all the sections to get the entire text.  For example, "3 abc 1 ab" expands out to "abcabcabcab" (3 instances of "abc" followed by 1 instance of "ab").  Return the minimal possible message length that could have produced the given text.
//
//
// DEFINITION
// Class:RunningLetters
// Method:newsLength
// Parameters:vector <string>
// Returns:int
// Method signature:int newsLength(vector <string> running)
//
//
// CONSTRAINTS
// -running will contain between 1 and 50 elements, inclusive.
// -Each element of running will contain between 0 and 50 characters, inclusive.
// -running will be formatted as described in the statement, where each N is an integer between 1 and 1000000, inclusive, with no leading zeroes, and each S is a non-empty string containing only lowercase letters ('a'-'z').
// -running will contain no leading, trailing, or consecutive spaces.
// -The expanded text will contain between 1 and 1000000 characters, inclusive.
//
//
// EXAMPLES
//
// 0)
// {"3 abc 1 ab"}
//
// Returns: 3
//
// This is the example from the problem statement.
//
// 1)
// {"1 babaaba"}
//
// Returns: 5
//
// The text "babaaba" can be produce by the message "abaab".
//
// 2)
// {"1 ba 1 c 1 bacba 3 cba"}
//
// Returns: 3
//
// 3)
// {"42 runningletters 42 runningletters 1 running"}
//
// Returns: 14
//
// 4)
// {"1 b ", "1 a ", "1 b ", "1 a", " 1 b"}
//
// Returns: 2
//
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
