#include <bits/stdc++.h>

#define out freopen("output.txt", "w", stdout);
#define in freopen("input.txt", "r", stdin);
#define clr(arr, key) memset(arr, key, sizeof arr)
#define pub push_back
#define pob pop_back
#define infinity 2147483647
#define LL long long
#define Pi acos(-1)
#define SZ 100010
#define VI vector <int>

#define _ ios_base::sync_with_stdio(0);cin.tie(0);

///int col[8] = {0, 1, 1, 1, 0, -1, -1, -1};
///int row[8] = {1, 1, 0, -1, -1, -1, 0, 1};
///int col[4] = {1, 0, -1, 0};
///int row[4] = {0, 1, 0, -1};
///int months[13] = {0, ,31,28,31,30,31,30,31,31,30,31,30,31};

struct point{int x, y;};

template <class T> T sqr(T a){return a * a;};
template <class T> double getdist(T a, T b){return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));}
template <class T> T GCD(T a, T b) {if(b == 0) return a; return GCD(b, a % b);}
template <class T> T LCM(T a, T b) {return (a * b) / GCD(a, b);}

using namespace std;

class SquareCovering {
public:
	int getMinimalSide(vector <int> px, vector <int> py) {
        int i, sx = *min_element(px.begin(), px.end()), bx = *max_element(px.begin(), px.end()),
        sy = *min_element(py.begin(), py.end()), by = *max_element(py.begin(), py.end());
        for(i = 0; i < px.size(); i++){
                if(px[i] > sx && px[i] < bx && py[i] > sy && py[i] < by)
                    return -1;
            }
            sort(px.begin(), px.end());
        cout << 1 - *(px.rend()--) << endl;
        if(bx - sx == by - sy)
            return bx - sx;
        if(bx - sx > by - sy){
            bool a = false;
            bool b = false;
            for(i = 0; i < px.size(); i++){
                if(px[i] > sx && px[i] < bx){
                        if(py[i] == sy)
                            a = true;
                        if(py[i] == by)
                            b = true;
                }
            }
            if(a && b && sy != by) return -1;
            else return bx - sx;
        }
        else{
            bool a = false;
            bool b = false;
            for(i = 0; i < py.size(); i++){
                if(py[i] > sy && py[i] < by){
                        if(px[i] == sx)
                            a = true;
                        if(px[i] == bx)
                            b = true;
                }
            }
            if(a && b && sx != bx) return -1;
            else return by - sy;
        }
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	SquareCovering *obj;
	int answer;
	obj = new SquareCovering();
	clock_t startTime = clock();
	answer = obj->getMinimalSide(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <int> p0;
	vector <int> p1;
	int p2;

	{
	// ----- test 0 -----
	int t0[] = {-1, 1, 1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1, 4, -1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	int t0[] = {0, 0, 0, 1, 2, 3, 4, 4, 4};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {3, 2, 1, 4, 4, 4, 1, 2, 3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 4;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	int t0[] = {1,-3,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,0,-4};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 5;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	int t0[] = {-10,0,3,-1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,-1,3,4};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = -1;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	int t0[] = {1,2,3,4,5,6,7,8,9,10};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1000,1000,1000,1000,1000,1000,1000,1000,1000,1000};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 9;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
//
// A square covers a point on a plane if this point lies on the border of this square.
//
//
// You will be given vector <int>s px and py, with the i-th elements of px and py representing x and y coordinates of a point on a plane.
// Find the smallest square with its sides parallel to coordinate axes, which can cover all points from the input and return the length of its side.
// If no such square exists, return -1.
//
//
// DEFINITION
// Class:SquareCovering
// Method:getMinimalSide
// Parameters:vector <int>, vector <int>
// Returns:int
// Method signature:int getMinimalSide(vector <int> px, vector <int> py)
//
//
// CONSTRAINTS
// -px will contain between 2 and 50 elements, inclusive.
// -px and py will contain the same number of elements.
// -All elements of px and py will be between -1000 and 1000, inclusive.
// -All points specified by px and py will be different.
//
//
// EXAMPLES
//
// 0)
// {0,1}
// {0,1}
//
// Returns: 1
//
// Both points can be covered with a square with vertices (0,0), (1,0), (1, 1) and (0, 1).
//
// 1)
// {0,1,2}
// {0,1,2}
//
// Returns: -1
//
// These points can not be covered by a square.
//
// 2)
// {1,-3, 2}
// {1, 0, -4}
//
// Returns: 5
//
//
//
// 3)
// {-10, 0, 3, -1}
// {0, -1, 3, 4}
//
// Returns: -1
//
// These points can be covered by a rectangle, but not by a square.
//
// 4)
// {1,2,3,4,5,6,7,8,9,10}
// {1000,1000,1000,1000,1000,1000,1000,1000,1000,1000}
//
// Returns: 9
//
//
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
