#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

#define out freopen("output.txt", "w", stdout);
#define in freopen("input.txt", "r", stdin);
#define clr(arr, key) memset(arr, key, sizeof arr)
#define pb push_back
#define infinity 2147483647
#define LL long long
#define PI acos(-1)
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) ((a)*((b)/gcd(a,b)))
#define all(v) v.begin(), v.end()
#define no_of_ones __builtin_popcount // count 1's in a numbers binary representation
#define SZ(v) (int)(v.size())
#define eps 10e-7

int col8[8] = {0, 1, 1, 1, 0, -1, -1, -1};
int row8[8] = {1, 1, 0, -1, -1, -1, 0, 1};
int col[4] = {-1,0,1,0};
int row[4] = {0,-1,0,1};
//int months[13] = {0, ,31,28,31,30,31,30,31,31,30,31,30,31};

using namespace std;

//struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};    // for coordinates;

template <class T> T sqr(T a){return a * a;}    // square
template <class T> T power(T n, T p) { T res = 1; for(int i = 0; i < p; i++) res *= n; return res;}     //  n  to the power p
template <class T> double getdist(T a, T b){return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));}    // distance between a and b
template <class T> T extract(string s, T ret) {stringstream ss(s); ss >> ret; return ret;}    // extract words or numbers from a line
template <class T> string tostring(T n) {stringstream ss; ss << n; return ss.str();}    // convert a number to string
template <class T> inline T Mod(T n,T m) {return (n%m+m)%m;}    // negative mod
template <class T> void print_all(T v) {for(int i = 0; i < v.size(); i++) cout << v[i] << ' ';};
template <class T> void print_all(T &v, int len) {for(int i = 0; i < len; i++) cout << v[i] << ' ';}     // prints all elements in a vector or array
template <class T> void print_pair(T v, int len) {for(int i = 0; i < len; i++) cout << v[i].first << ' ' << v[i].second << endl;} // prints pair vector
//LL bigmod(LL B,LL P,LL M){LL R=1; while(P>0)  {if(P%2==1){R=(R*B)%M;}P/=2;B=(B*B)%M;} return R;}

#define MAX 100010
/*************************************************HABIJABI ENDS HERE******************************************************/

class Quilting {
public:

    int ans[220][220];
    int used[20];
	string lastPatch(int length, int width, vector <string> colorList) {
        int x = 105, mx, i, tem, y = 105, nebo = 0, dir = 0, gone = 0, togo = 1, done = 0;
        clr(ans, -1);
        clr(used, 0);
        while(done < length * width)
        {
            done++;
            mx = infinity;
            nebo = 0;
            for(i = 0; i < SZ(colorList); i++)
            {
                tem = 0;
                for(int p = 0; p < 8; p++)
                {
                    if(ans[x + row8[p]][y + col8[p]] == i)
                        tem++;
                }
                if(tem < mx)
                    mx = tem, nebo = i;
                else if(tem == mx && used[nebo] > used[i])
                    mx = tem, nebo = i;
            }
            used[nebo]++;
            ans[x][y] = nebo;
            x += row[dir];
            y += col[dir];
            gone++;
            if(gone == togo)
            {
                dir = (dir + 1) % 4;
                if(!(dir & 1))
                    togo++;
                gone = 0;
            }
        }
        return colorList[nebo];
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, vector <string> p2, bool hasAnswer, string p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p2[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	Quilting *obj;
	string answer;
	obj = new Quilting();
	clock_t startTime = clock();
	answer = obj->lastPatch(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p3 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;

	int p0;
	int p1;
	vector <string> p2;
	string p3;

	// ----- test 0 -----
	disabled = false;
	p0 = 3;
	p1 = 2;
	p2 = {"RED","BLUE","TAN"};
	p3 = "TAN";
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 1 -----
	disabled = false;
	p0 = 4;
	p1 = 3;
	p2 = {"E","D","C","B","A"};
	p3 = "E";
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 2 -----
	disabled = false;
	p0 = 3;
	p1 = 3;
	p2 = {"A","B","C","D"};
	p3 = "C";
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 3 -----
	disabled = false;
	p0 = 1;
	p1 = 1;
	p2 = {"RED","BLUE","YELLOW"};
	p3 = "RED";
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 4 -----
	disabled = false;
	p0 = 10;
	p1 = 10;
	p2 = {"X","Y","Z"};
	p3 = "Z";
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// A quilt is made by sewing square patches of different colors together in
// a pattern.  We are using a pattern that says to start with one patch, and then add patches starting with the patch above it and continuing by spiraling outward counterclockwise until we
// have the desired size. The picture below shows the order of the patches (a then b then c etc.)
// in crafting a quilt whose length(i.e. height) is 4 and whose width is 3.
//
//           lkj
//           cbi
//           dah
//           efg
//
// Define the neighbors of a newly added patch to be
// all the previous patches that touch the new patch (including those that
// just touch diagonally at a corner).  The rules for choosing the color of
// the newly added patch are
//     1) choose a color that minimizes the number of neighbors of the same color
//     2) choose a color that has been used least often by previous patches
//     3) choose the earliest(lowest index) color in the colorList
//
// Rule 2 is applied only to decide among colors that are tied after rule 1 has been applied. Rule 3
// is applied only to decide among colors that are tied after the first two rules have been applied.
//
// Create a class Quilting that contains a method lastPatch that returns the color
// of the last patch added to the quilt.  Its inputs are an int length and an int
// width (the two dimensions of the finished quilt),  and
// a vector <string> colorList giving the
// available colors.  length minus width will be 0 or 1,
// so it will always be possible to produce a quilt of the given size.
//
//
//
// DEFINITION
// Class:Quilting
// Method:lastPatch
// Parameters:int, int, vector <string>
// Returns:string
// Method signature:string lastPatch(int length, int width, vector <string> colorList)
//
//
// CONSTRAINTS
// -width will be between 1 and 100 inclusive
// -length will be between 1 and 100 inclusive
// -length - width will be 0 or 1
// -colorList will have between 1 and 10 elements inclusive
// -each element of colorList will have between 1 and 15 characters inclusive
// -each element of colorList will contain only uppercase letters 'A'-'Z'
// -each element of colorList will be distinct
//
//
// EXAMPLES
//
// 0)
// 3
// 2
// {"RED","BLUE","TAN"}
//
// Returns: "TAN"
//
//
//
//        TAN  BLUE
//        RED  RED
//        BLUE TAN
//
// The layout above shows the finished quilt. It was created by starting at the position of the rightmost RED. (The color RED was chosen by rule 3). The BLUE above it was added next (RED was disqualified by rule 1, BLUE preferred over TAN by rule 3). Then TAN was chosen by rule 1, and then RED was chosen by rule 3. BLUE was chosen by rule 3 after RED was eliminated by rule 1. Finally the last patch was TAN by rule 1.
//
//
//
// 1)
// 4
// 3
// {"E","D","C","B","A"}
//
// Returns: "E"
//
//
//        E B E
//        C D A
//        B E B
//        A D C
//
// The layout above shows the finished quilt. It was created by starting at the position of E near the middle.(The color E was chosen by rule 3). The D above it was added next (E was disqualified by rule 1, the
// others were tied under rule 2, and D was preferred over the others by rule 3). The process continued until the final E in the upper left corner was chosen because B, C, and D were eliminated by rule 1, E and A were tied under rule 2 and E was preferred to A by rule 3.
//
//
// 2)
// 3
// 3
// {"A","B","C","D"}
//
// Returns: "C"
//
//
//
//              C B C
//              D A A
//              B C D
//
// This quilt was constructed by starting at the position of the middle A and
// then adding the B patch above it.  The final patch was the C in the
// upper right corner.
//
//
// 3)
// 1
// 1
// {"RED","BLUE","YELLOW"}
//
// Returns: "RED"
//
// 4)
// 10
// 10
// {"X","Y","Z"}
//
// Returns: "Z"
//
//
//   Z Y Z Y X Y X Z X Y
//   X X Z Y Z Y X Y X Z
//   Z Y Z X Z Y Z Y Z Y
//   X Z X Y X Y X Z X X
//   Y Z Y Z Z Y Z Y Y Y
//   Z X X X X X X Z X Z
//   Y Y Y Z Y Z Y Y Z Y
//   X X Z X Y X Z X X X
//   Y Z Y X Z X Y Z Y Y
//   Z X Y Z Y Z X Z X Z
//
//
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
