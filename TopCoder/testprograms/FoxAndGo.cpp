#include <bits/stdc++.h>

#define out freopen("output.txt", "w", stdout);
#define in freopen("input.txt", "r", stdin);
#define clr(arr, key) memset(arr, key, sizeof arr)
#define pb push_back
#define infinity 2147483647
#define LL long long
#define PI acos(-1)
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) ((a)*((b)/gcd(a,b)))
#define all(v) v.begin(), v.end()
#define no_of_ones __builtin_popcount // count 1's in a numbers binary representation
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

#define F(i, n) for(i = 0; i < n; i++)

//int col[8] = {0, 1, 1, 1, 0, -1, -1, -1};
//int row[8] = {1, 1, 0, -1, -1, -1, 0, 1};
int col[4] = {1, 0, -1, 0};
int row[4] = {0, 1, 0, -1};
//int months[13] = {0, ,31,28,31,30,31,30,31,31,30,31,30,31};

using namespace std;

struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};    // for coordinates;

template <class T> T sqr(T a){return a * a;}    // square
template <class T> T power(T n, T p) { T res = 1; for(int i = 0; i < p; i++) res *= n; return res;}     //  n  to the power p
template <class T> double getdist(T a, T b){return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));}    // distance between a and b
template <class T> T extract(string s, T ret) {stringstream ss(s); ss >> ret; return ret;}    // extract words or numbers from a line
template <class T> string tostring(T n) {stringstream ss; ss << n; return ss.str;}    // convert a number to string
template <class T> inline T Mod(T n,T m) {return (n%m+m)%m;}    // negative mod
template <class T> void print_all(T v) {for(int i = 0; i < v.size(); i++) cout << v[i] << ' ';};
template <class T> void print_all(T &v, int len) {for(int i = 0; i < len; i++) cout << v[i] << ' ';}     // prints all elements in a vector or array
template <class T> void print_pair(T v, int len) {for(int i = 0; i < len; i++) cout << v[i].first << ' ' << v[i].second << endl;} // prints pair vector
//LL bigmod(LL B,LL P,LL M){  LL R=1; while(P>0)  {if(P%2==1){R=(R*B)%M;}P/=2;B=(B*B)%M;} return R;}

#define SZ 1000010
/*************************************************HABIJABI ENDS HERE******************************************************/

int color[20][20], cnt, n, dot_count;
vector <string> arr;

void dfs(int x, int y)
{
    for(int i = 0; i < 4; i++)
    {
        int nr = x + row[i];
        int nc = y + col[i];
        if(nr >= 0 && nr < n && nc >= 0 && nc < n && color[nr][nc] == 0)
        {
            if(arr[nr][nc] == '.')
            {
                color[nr][nc] = 1;
                dot_count++;
                cout << nr << ' ' << nc << endl;
            }
            else if(arr[nr][nc] == 'o')
            {
                color[nr][nc] = 1;
                cnt++;
                dfs(nr, nc);
            }
        }
    }
}

class FoxAndGo {
public:
	int maxKill(vector <string> board) {
	_
	arr = board;
	int mx = 0, i, j, dot;
	clr(color, 0);
    dot_count = 0;
    int flag = 0;
	n = board.size();
	F(i, n)
	{
	    F(j, n)
	    {
	        if(color[i][j])
                continue;
	        if(board[i][j] == 'o')
            {
                cnt = 1;
                color[i][j] = 1;
                dfs(i, j);
//                cout << "count" << cnt << ' ' << dot_count << endl;
                if(dot_count <= 1)
                {mx = max(mx, cnt);
                    dot_count++;
                    flag = 1;
                }
                if(flag && dot_count == 1)
                    mx += cnt;
            }
	    }
	}
	return mx;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	FoxAndGo *obj;
	int answer;
	obj = new FoxAndGo();
	clock_t startTime = clock();
	answer = obj->maxKill(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <string> p0;
	int p1;

	{
	// ----- test 0 -----
	string t0[] = {".....","..x..",".xox.",".....","....."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	string t0[] = {"ooooo","xxxxo","xxxx.","xxxx.","ooooo"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 6;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	string t0[] = {".xoxo","ooxox","oooxx","xoxox","oxoox"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 13;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	string t0[] = {".......",".......",".......","xxxx...","ooox...","ooox...","ooox..."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 9;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	string t0[] = {".......",".xxxxx.",".xooox.",".xo.ox.",".xooox.",".xxxxx.","......."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 8;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 5 -----
	string t0[] = {"o.xox.o","..xox..","xxxoxxx","ooo.ooo","xxxoxxx","..xox..","o.xox.o"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 12;
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 6 -----
	string t0[] = {".......","..xx...",".xooox.",".oxxox.",".oxxxo.","...oo..","......."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 7 -----
	string t0[] = {".ox....","xxox...","..xoox.","..xoox.","...xx..",".......","......."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	all_right = KawigiEdit_RunTest(7, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 8 -----
	string t0[] = {"...................","...................","...o..........o....","................x..","...............x...","...................","...................","...................","...................","...................","...................","...................","...................","...................","................o..","..x................","...............x...","...................","..................."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(8, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Fox Ciel is teaching her friend Jiro to play Go.
// Ciel has just placed some white and some black tokens onto a board.
// She now wants Jiro to find the best possible move.
// (This is defined more precisely below.)
//
//
// You are given a vector <string> board.
// Character j of element i of board represents the cell (i,j) of the board:
// 'o' is a cell with a white token, 'x' a cell with a black token, and '.' is an empty cell.
// At least one cell on the board will be empty.
//
//
// Jiro's move will consist of adding a single black token to the board.
// The token must be placed onto an empty cell.
// Once Jiro places the token, some white tokens will be removed from the board according to the rules described in the next paragraphs.
//
//
// The white tokens on the board can be divided into connected components using the following rules:
// If two white tokens lie in cells that share an edge, they belong to the same component.
// Being in the same component is transitive: if X lies in the same component as Y and Y lies in the same component as Z, then X lies in the same component as Z.
//
//
// Each component of white tokens is processed separately.
// For each component of white tokens we check whether it is adjacent to an empty cell.
// (That is, whether there are two cells that share an edge such that one of them is empty and the other contains a white token from the component we are processing.)
// If there is such an empty cell, the component is safe and its tokens remain on the board.
// If there is no such empty cell, the component is killed and all its tokens are removed from the board.
//
//
// Jiro's score is the total number of white tokens removed from the board after he makes his move.
// Return the maximal score he can get for the given board.
//
//
// DEFINITION
// Class:FoxAndGo
// Method:maxKill
// Parameters:vector <string>
// Returns:int
// Method signature:int maxKill(vector <string> board)
//
//
// NOTES
// -The position described by board does not have to be a valid Go position. In particular, there can already be components of white tokens that have no adjacent empty cell.
// -Please ignore official Go rules. The rules described in the problem statement are slightly different. For example, in this problem the black tokens cannot be killed, and it is allowed to place the black token into any empty cell.
//
//
// CONSTRAINTS
// -n will be between 2 and 19, inclusive.
// -board will contain exactly n elements.
// -Each element in board will contain exactly n characters.
// -Each character in board will be 'o', 'x' or '.'.
// -There will be at least one '.' in board.
//
//
// EXAMPLES
//
// 0)
// {".....",
//  "..x..",
//  ".xox.",
//  ".....",
//  "....."}
//
//
// Returns: 1
//
// To kill the only white token, Jiro must place his black token into the cell (3,2). (Both indices are 0-based.)
//
// 1)
// {"ooooo",
//  "xxxxo",
//  "xxxx.",
//  "xxxx.",
//  "ooooo"}
//
//
// Returns: 6
//
// By placing the token to the cell (2,4) Jiro kills 6 white tokens. The other possible move only kills 5 tokens.
//
// 2)
// {".xoxo",
//  "ooxox",
//  "oooxx",
//  "xoxox",
//  "oxoox"}
//
//
// Returns: 13
//
// There is only one possible move. After Jiro makes it, all the white tokens are killed.
//
// 3)
// {".......",
//  ".......",
//  ".......",
//  "xxxx...",
//  "ooox...",
//  "ooox...",
//  "ooox..."}
//
//
// Returns: 9
//
// Regardless of where Jiro moves, the 9 white tokens in the lower left corner will be killed.
//
// 4)
// {".......",
//  ".xxxxx.",
//  ".xooox.",
//  ".xo.ox.",
//  ".xooox.",
//  ".xxxxx.",
//  "......."}
//
//
// Returns: 8
//
//
//
// 5)
// {"o.xox.o",
//  "..xox..",
//  "xxxoxxx",
//  "ooo.ooo",
//  "xxxoxxx",
//  "..xox..",
//  "o.xox.o"}
//
//
// Returns: 12
//
//
//
// 6)
// {".......",
//  "..xx...",
//  ".xooox.",
//  ".oxxox.",
//  ".oxxxo.",
//  "...oo..",
//  "......."}
//
// Returns: 4
//
//
//
// 7)
// {".ox....",
//  "xxox...",
//  "..xoox.",
//  "..xoox.",
//  "...xx..",
//  ".......",
//  "......."}
//
//
// Returns: 5
//
//
//
// 8)
// {"...................",
//  "...................",
//  "...o..........o....",
//  "................x..",
//  "...............x...",
//  "...................",
//  "...................",
//  "...................",
//  "...................",
//  "...................",
//  "...................",
//  "...................",
//  "...................",
//  "...................",
//  "................o..",
//  "..x................",
//  "...............x...",
//  "...................",
//  "..................."}
//
//
// Returns: 0
//
//
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
